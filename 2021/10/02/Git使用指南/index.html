<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Git 使用指南 - Bruce Han&#039;s Blog</title><link rel="manifest" href="../../../../manifest.json"><meta name="application-name" content="Bruce Han&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Bruce Han&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Git 的基本用法"><meta property="og:type" content="blog"><meta property="og:title" content="Git 使用指南"><meta property="og:url" content="https://brucehan98@github.io/2021/10/02/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"><meta property="og:site_name" content="Bruce Han&#039;s Blog"><meta property="og:description" content="Git 的基本用法"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://pic2.zhimg.com/80/v2-3bc9d5f2c49a713c776e69676d7d56c5_1440w.webp"><meta property="og:image" content="https://img-1307246870.cos.ap-beijing.myqcloud.com/lifecycle.png"><meta property="og:image" content="https://git-scm.com/book/en/v2/images/commit-and-tree.png"><meta property="og:image" content="https://git-scm.com/book/en/v2/images/commits-and-parents.png"><meta property="og:image" content="https://git-scm.com/book/en/v2/images/two-branches.png"><meta property="og:image" content="https://git-scm.com/book/en/v2/images/basic-branching-2.png"><meta property="og:image" content="https://git-scm.com/book/en/v2/images/basic-branching-3.png"><meta property="og:image" content="https://git-scm.com/book/en/v2/images/basic-branching-4.png"><meta property="og:image" content="https://git-scm.com/book/en/v2/images/basic-branching-5.png"><meta property="og:image" content="https://git-scm.com/book/en/v2/images/basic-merging-1.png"><meta property="og:image" content="https://git-scm.com/book/en/v2/images/basic-merging-2.png"><meta property="article:published_time" content="2021-10-02T02:41:37.000Z"><meta property="article:modified_time" content="2023-06-19T07:24:53.465Z"><meta property="article:author" content="Bruce Han"><meta property="article:tag" content="git"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://pic2.zhimg.com/80/v2-3bc9d5f2c49a713c776e69676d7d56c5_1440w.webp"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://brucehan98@github.io/2021/10/02/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},"headline":"Git 使用指南","image":["https://pic2.zhimg.com/80/v2-3bc9d5f2c49a713c776e69676d7d56c5_1440w.webp","https://img-1307246870.cos.ap-beijing.myqcloud.com/lifecycle.png","https://git-scm.com/book/en/v2/images/commit-and-tree.png","https://git-scm.com/book/en/v2/images/commits-and-parents.png","https://git-scm.com/book/en/v2/images/two-branches.png","https://git-scm.com/book/en/v2/images/basic-branching-2.png","https://git-scm.com/book/en/v2/images/basic-branching-3.png","https://git-scm.com/book/en/v2/images/basic-branching-4.png","https://git-scm.com/book/en/v2/images/basic-branching-5.png","https://git-scm.com/book/en/v2/images/basic-merging-1.png","https://git-scm.com/book/en/v2/images/basic-merging-2.png"],"datePublished":"2021-10-02T02:41:37.000Z","dateModified":"2023-06-19T07:24:53.465Z","author":{"@type":"Person","name":"Bruce Han"},"publisher":{"@type":"Organization","name":"Bruce Han's Blog","logo":{"@type":"ImageObject","url":"https://brucehan98@github.io/img/logo.svg"}},"description":"Git 的基本用法"}</script><link rel="canonical" href="https://brucehan98@github.io/2021/10/02/Git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"><link rel="icon" href="../../../../img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/6.0.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/xcode.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="../../../../css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="../../../../index.html"><img src="../../../../img/logo.svg" alt="Bruce Han&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="../../../../index.html">首页</a><a class="navbar-item" href="../../../../archives">归档</a><a class="navbar-item" href="../../../../categories">分类</a><a class="navbar-item" href="../../../../tags">标签</a><a class="navbar-item" href="../../../../about">关于</a></div><div class="navbar-end"><a class="navbar-item night" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com/BruceHan98"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article" style="padding-left: 2rem; padding-right: 2rem; padding-top: 1rem; padding-bottom: 1rem"><h1 class="title is-size-4 is-size-4-mobile" style="font-weight: bold; margin: 0.5rem 0;">Git 使用指南</h1><div class="article-meta is-size-6 is-uppercase level is-mobile" style="margin-top: 0.5rem;"><div class="level-left"><span class="level-item"><time dateTime="2021-10-02T02:41:37.000Z" title="2021-10-02T02:41:37.000Z">2021-10-02</time>发表</span><span class="level-item"><time dateTime="2023-06-19T07:24:53.465Z" title="2023-06-19T07:24:53.465Z">2023-06-19</time>更新</span><span class="level-item"><a class="link-muted" href="../../../../categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/">工具使用</a></span><span class="level-item">31 分钟读完</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><div class="content" style="margin-top: 0.5rem; margin-bottom: 0.5rem;"><h3></h3><h3 id="1-工作原理"><a href="#1-工作原理" class="headerlink" title="1. 工作原理"></a>1. 工作原理</h3><p><img src="https://pic2.zhimg.com/80/v2-3bc9d5f2c49a713c776e69676d7d56c5_1440w.webp" alt="img"></p>
<p><strong>Workspace</strong>：工作区<br><strong>Index / Stage</strong>：暂存区<br><strong>Repository</strong>：本地仓库<br><strong>Remote</strong>：远程仓库</p>
<p>基本的 Git 工作流程如下：</p>
<ol>
<li>在工作区中修改文件。</li>
<li>将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。</li>
<li>提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。</li>
</ol>
<h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h3><p><strong>用户信息</strong></p>
<p>设置你的用户名和邮件地址：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config --global user.name <span class="hljs-string">&quot;John Doe&quot;</span><br>$ git config --global user.email johndoe@example.com<br></code></pre></td></tr></table></figure>
<p><strong>检查配置信息</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config --list<br></code></pre></td></tr></table></figure>
<p><strong>设置代理</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config --global http.proxy <span class="hljs-string">&#x27;http://127.0.0.1:1080&#x27;</span><br>$ git config --global https.proxy <span class="hljs-string">&#x27;https://127.0.0.1:1080&#x27;</span><br></code></pre></td></tr></table></figure>
<h3 id="3-获取-Git-仓库"><a href="#3-获取-Git-仓库" class="headerlink" title="3. 获取 Git 仓库"></a>3. 获取 Git 仓库</h3><p><strong>新建仓库</strong></p>
<ol>
<li>通过 Github 创建个人仓库。</li>
<li>在本地的仓库路径下，初始化 git 项目</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git init</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add &lt;your_files&gt;</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git commit -m <span class="hljs-string">&quot;commit message&quot;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -M main</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git remote add origin &lt;your_git&gt;</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git push -u origin main</span><br></code></pre></td></tr></table></figure>
<p><strong>克隆现有的仓库</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> https://github.com/libgit2/libgit2<br></code></pre></td></tr></table></figure>
<h3 id="4-记录更新"><a href="#4-记录更新" class="headerlink" title="4. 记录更新"></a>4. 记录更新</h3><p>工作目录下的每一个文件都不外乎这两种状态：<strong>已跟踪</strong> 或 <strong>未跟踪</strong>。 已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后， 它们的状态可能是未修改，已修改或已放入暂存区。</p>
<p>编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。 在工作时，你可以选择性地将这些修改过的文件放入暂存区，然后提交所有已暂存的修改，如此反复。</p>
<p><img src="https://img-1307246870.cos.ap-beijing.myqcloud.com/lifecycle.png" alt="Git 下文件生命周期图。" style="zoom:67%;" /></p>
<p><strong>检查当前文件状态</strong></p>
<p>可以用 <code>git status</code> 命令查看哪些文件处于什么状态。</p>
<p>在项目下创建一个新的 <code>README</code> 文件，新建的 <code>README</code> 文件出现在 <code>Untracked files</code> 下面。 未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些文件；Git 不会自动将之纳入跟踪范围。</p>
<p><strong>跟踪新文件</strong></p>
<p>使用命令 <code>git add</code> 开始跟踪一个文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git add README<br></code></pre></td></tr></table></figure>
<p>此时再运行 <code>git status</code> 命令，会看到 <code>README</code> 文件已被跟踪，并处于暂存状态。在 <code>Changes to be committed</code> 这行下面的，就说明是已暂存状态。</p>
<p><strong>暂存已修改的文件</strong></p>
<p>修改一个已被跟踪的文件，出现在 <code>Changes not staged for commit</code> 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。要暂存这次更新，需要运行 <code>git add</code> 命令。</p>
<p><code>git add</code> 是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。将这个命令理解为“精确地将内容添加到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。</p>
<p>运行了 <code>git add</code> 之后又作了修订的文件，需要重新运行 <code>git add</code> 把最新版本重新暂存起来。</p>
<p><strong>忽略文件</strong></p>
<p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 在这种情况下，我们可以创建一个名为 <code>.gitignore</code> 的文件，列出要忽略的文件的模式。GitHub 有一个十分详细的针对数十种项目及语言的 <code>.gitignore</code> 文件列表， 你可以在 <a target="_blank" rel="noopener" href="https://github.com/github/gitignore">https://github.com/github/gitignore</a> 找到它。</p>
<p><strong>查看已暂存和未暂存的修改</strong></p>
<p>想知道具体修改了什么地方，可以用 <code>git diff</code> 命令。</p>
<p>要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 <code>git diff</code>，此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是<strong>修改之后还没有暂存</strong>起来的变化内容。</p>
<p>若要查看已暂存的将要添加到下次提交里的内容，可以用 <code>git diff --staged</code> 命令。这条命令将比对<strong>已暂存文件与最后一次提交</strong>的文件差异。</p>
<p>请注意，<code>git diff</code> 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。</p>
<p><strong>提交更新</strong></p>
<p>现在的暂存区已经准备就绪，可以提交了。在此之前，请务必确认还有什么已修改或新建的文件还没有 <code>git add</code> 过， 否则提交的时候不会记录这些尚未暂存的变化。所以，每次准备提交前，先用 <code>git status</code> 看下，你所需要的文件是不是都已暂存起来了， 然后再运行提交命令 <code>git commit</code>。</p>
<p>每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。</p>
<p><strong>跳过暂存</strong></p>
<p>尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。只要在提交的时候，给 <code>git commit</code> 加上 <code>-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤。这很方便，但是要小心，有时这个选项会将不需要的文件添加到提交中。</p>
<p><strong>移除文件</strong></p>
<p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。可以用 <code>git rm</code> 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p>
<p>如果只是简单地从工作目录中手工删除文件，删除的文件会记录在“Changes not staged for commit” 中，需要再运行 <code>git rm</code> 记录此次移除文件的操作，下一次提交时，该文件就不再纳入版本管理了。</p>
<p> 如果要删除之前修改过或已经放到暂存区的文件，则必须使用强制删除选项 <code>-f</code>。</p>
<p>另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。当你忘记添加 <code>.gitignore</code> 文件，不小心把一个很大的日志文件或一堆 <code>.a</code> 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 <code>--cached</code> 选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">rm</span> --cached README<br></code></pre></td></tr></table></figure>
<p><strong>移动文件</strong></p>
<p>Git 并不显式跟踪文件移动操作。 如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。 不过 Git 非常聪明，它会推断出究竟发生了什么。想要移动文件或重命名，你可以进行以下操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">mv</span> README.md README<br></code></pre></td></tr></table></figure>
<p>其实，运行 <code>git mv</code> 就相当于运行了下面三条命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">mv</span> README.md README<br>$ git <span class="hljs-built_in">rm</span> README.md<br>$ git add README<br></code></pre></td></tr></table></figure>
<p>两者唯一的区别在于，<code>git mv</code> 是一条命令而非三条命令，直接使用 <code>git mv</code> 方便得多。 不过在使用其他工具重命名文件时，记得在提交前 <code>git rm</code> 删除旧文件名，再 <code>git add</code> 添加新文件名。</p>
<h3 id="5-查看提交历史"><a href="#5-查看提交历史" class="headerlink" title="5. 查看提交历史"></a>5. 查看提交历史</h3><p>运行 <code>git log</code> 命令时，会按时间先后顺序列出所有的提交，最近的更新排在最上面。这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。</p>
<p>一个比较有用的选项是 <code>-p</code> 或 <code>--patch</code> ，它会显示每次提交所引入的差异（按 <strong>补丁</strong> 的格式输出）。 你也可以限制显示的日志条目数量，例如使用 <code>-2</code> 选项来只显示最近的两次提交：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span> -p -2<br></code></pre></td></tr></table></figure>
<p>该选项除了显示基本信息之外，还附带了每次提交的变化。 </p>
<p>想看到每次提交的简略统计信息，可以使用 <code>--stat</code> 选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">log</span> --<span class="hljs-built_in">stat</span><br></code></pre></td></tr></table></figure>
<p>另一个非常有用的选项是 <code>--pretty</code>。 这个选项可以使用不同于默认格式的方式展示提交历史。比如 <code>oneline</code> 会将每个提交放在一行显示，在浏览大量的提交时非常有用。 另外还有 <code>short</code>，<code>full</code> 和 <code>fuller</code> 选项，它们展示信息的格式基本一致，但是详尽程度不一：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">log</span> --pretty=oneline<br></code></pre></td></tr></table></figure>
<p><code>format</code> ，可以定制记录的显示格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">log</span> --pretty=format:<span class="hljs-string">&quot;%h - %an, %ar : %s&quot;</span><br></code></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th><code>%H</code></th>
<th>提交的完整哈希值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>%h</code></td>
<td>提交的简写哈希值</td>
</tr>
<tr>
<td><code>%an</code></td>
<td>作者名字</td>
</tr>
<tr>
<td><code>%ae</code></td>
<td>作者的电子邮件地址</td>
</tr>
<tr>
<td><code>%cn</code></td>
<td>提交者的名字</td>
</tr>
<tr>
<td><code>%ce</code></td>
<td>提交者的电子邮件地址</td>
</tr>
<tr>
<td><code>%cd</code></td>
<td>提交日期</td>
</tr>
<tr>
<td><code>%cr</code></td>
<td>提交日期（距今多长时间）</td>
</tr>
<tr>
<td><code>%s</code></td>
<td>提交说明</td>
</tr>
</tbody>
</table>
</div>
<p>作者指的是实际作出修改的人，提交者指的是最后将此工作成果提交到仓库的人。</p>
<h3 id="6-撤销操作"><a href="#6-撤销操作" class="headerlink" title="6. 撤销操作"></a>6. 撤销操作</h3><p><strong>修补上一次提交</strong></p>
<p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 <code>--amend</code> 选项的提交命令来重新提交：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git commit --amend<br></code></pre></td></tr></table></figure>
<p>这个命令会将暂存区中的文件提交。如果自上次提交以来你还未做任何修改，那么快照会保持不变，而你所修改的只是提交信息。例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git commit -m <span class="hljs-string">&#x27;initial commit&#x27;</span><br>$ git add forgotten_file<br>$ git commit --amend<br></code></pre></td></tr></table></figure>
<p>最终你只会有一个提交——第二次提交将代替第一次提交的结果。实际上，这是完全用一个 <strong>新的提交</strong> 替换旧的提交。</p>
<p><strong>取消暂存的文件</strong></p>
<p>使用 <code>git reset HEAD &lt;file&gt;…</code> 来取消暂存的文件。</p>
<p><strong>撤消对文件的修改</strong></p>
<p>如果你并不想保留对文件的修改，如何方便地撤消修改——将它还原成上次提交时的样子？<code>git checkout -- &lt;file&gt;...</code> 命令能够撤销暂存区中文件在本地的修改——Git 会用最近提交的版本覆盖掉它。</p>
<p>请务必记得 <code>git checkout — &lt;file&gt;</code> 是一个危险的命令。</p>
<h3 id="7-管理远程仓库"><a href="#7-管理远程仓库" class="headerlink" title="7. 管理远程仓库"></a>7. 管理远程仓库</h3><p><strong>查看远程仓库</strong></p>
<p>运行 <code>git remote</code> 命令，会列出你指定的每一个远程服务器的简写。如果你已经克隆了自己的仓库，那么至少应该能看到 origin ——这是 Git 给你克隆的仓库服务器的默认名字。</p>
<p>可以指定选项 <code>-v</code>，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。如果你的远程仓库不止一个，该命令会将它们全部列出。这表示我们能非常方便地拉取其它用户的贡献。</p>
<p><strong>添加远程仓库</strong></p>
<p>运行 <code>git remote add &lt;shortname&gt; &lt;url&gt;</code> 添加一个新的远程 Git 仓库，同时指定一个方便使用的简写：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git remote<br>origin<br>$ git remote add pb https://github.com/paulboone/ticgit<br>$ git remote -v<br>origin	https://github.com/schacon/ticgit (fetch)<br>origin	https://github.com/schacon/ticgit (push)<br>pb	https://github.com/paulboone/ticgit (fetch)<br>pb	https://github.com/paulboone/ticgit (push)<br></code></pre></td></tr></table></figure>
<p>如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 <code>git fetch pb</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git fetch pb<br></code></pre></td></tr></table></figure>
<p><strong>从远程仓库中抓取与拉取</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git fetch &lt;remote&gt;<br></code></pre></td></tr></table></figure>
<p>这个命令会访问远程仓库，从中拉取所有你还没有的数据，可以随时合并或查看。</p>
<p>注意 <code>git fetch</code> 命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。</p>
<p><code>git pull</code> 命令会自动抓取后合并该远程分支到当前分支。</p>
<p><strong>推送到远程仓库</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push &lt;remote&gt; &lt;branch&gt;<br></code></pre></td></tr></table></figure>
<p>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。</p>
<p>当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。你必须先抓取他们的工作并将其合并进你的工作后才能推送。</p>
<p><strong>远程仓库的重命名与移除</strong></p>
<p>运行 <code>git remote rename</code> 来修改一个远程仓库的简写名。例如，想要将 <code>pb</code> 重命名为 <code>paul</code>，可以用 <code>git remote rename</code> 这样做：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git remote rename pb paul<br></code></pre></td></tr></table></figure>
<p>这同样也会修改你所有远程跟踪的分支名字。</p>
<p>如果想要移除一个远程仓库，可以使用 <code>git remote remove</code> 或 <code>git remote rm</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git remote remove paul<br></code></pre></td></tr></table></figure>
<p>一旦你使用这种方式删除了一个远程仓库，那么所有和这个远程仓库相关的远程跟踪分支以及配置信息也会一起被删除。</p>
<h3 id="8-打标签"><a href="#8-打标签" class="headerlink" title="8. 打标签"></a>8. 打标签</h3><p>Git 可以给仓库历史中的某一个提交打上标签，以示重要。</p>
<p><strong>列出标签</strong></p>
<p>只需要输入 <code>git tag</code></p>
<p>也可以按照特定的模式查找标签。例如，如果只对 1.8.5 系列感兴趣，可以运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git tag -l <span class="hljs-string">&quot;v1.8.5*&quot;</span><br></code></pre></td></tr></table></figure>
<p><strong>创建标签</strong></p>
<p>Git 支持两种标签：轻量标签（lightweight）与附注标签（annotated）。</p>
<ul>
<li>轻量标签</li>
</ul>
<p>轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。创建轻量标签，只需要提供标签名字：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git tag v1.4-lw<br></code></pre></td></tr></table></figure>
<p>这时，如果在标签上运行 <code>git show</code>，你不会看到额外的标签信息。 命令只会显示出提交信息。</p>
<ul>
<li>辅助标签</li>
</ul>
<p>附注标签是存储在 Git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 GNU Privacy Guard （GPG）签名并验证。</p>
<p>在 Git 中创建附注标签十分简单。 最简单的方式是当你在运行 <code>tag</code> 命令时指定 <code>-a</code> 选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git tag -a v1.4 -m <span class="hljs-string">&quot;my version 1.4&quot;</span><br>$ git tag<br>v0.1<br>v1.3<br>v1.4<br></code></pre></td></tr></table></figure>
<p><code>-m</code> 选项指定了一条将会存储在标签中的信息。 通过使用 <code>git show</code> 命令可以看到标签信息和与之对应的提交信息。</p>
<p><strong>后期打标签</strong></p>
<p>假设在 v1.2 时你忘记给项目打标签，你可以在之后补上标签。 要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git tag -a v1.2 9fceb02<br></code></pre></td></tr></table></figure>
<p><strong>共享标签</strong></p>
<p>默认情况下，<code>git push</code> 命令并不会传送标签到远程仓库服务器上。在创建完标签后你必须显式地推送标签到共享服务器上。这个过程就像共享远程分支一样——你可以运行 <code>git push origin &lt;tagname&gt;</code>。</p>
<p>如果想要一次性推送很多标签，也可以使用带有 <code>--tags</code> 选项的 <code>git push</code> 命令。 这将会把所有不在远程仓库服务器上的标签全部传送到那里。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push origin --tags<br></code></pre></td></tr></table></figure>
<p><strong>删除标签</strong></p>
<p>要删除掉你本地仓库上的标签，可以使用命令 <code>git tag -d &lt;tagname&gt;</code>。注意上述命令并不会从任何远程仓库中移除这个标签，你必须用 <code>git push &lt;remote&gt; :refs/tags/&lt;tagname&gt;</code> 来更新你的远程仓库。</p>
<p>第二种更直观的删除远程标签的方式是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push origin --delete &lt;tagname&gt;<br></code></pre></td></tr></table></figure>
<h3 id="9-Git-分支"><a href="#9-Git-分支" class="headerlink" title="9. Git 分支"></a>9. Git 分支</h3><p>Git 保存的不是文件的变化或者差异，而是一系列不同时刻的<strong>快照</strong>。</p>
<p>在进行提交操作时，Git 会保存一个提交对象（commit object）。该提交对象会包含一个指向暂存内容快照的指针。</p>
<p>当使用 <code>git commit</code> 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和， 然后在 Git 仓库中这些校验和保存为树对象。随后，Git 便会创建一个提交对象， 它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。 如此一来，Git 就可以在需要的时候重现此次保存的快照。</p>
<p>现在，Git 仓库中有五个对象：三个 <em>blob</em> 对象（保存着文件快照）、一个 <strong>树</strong> 对象 （记录着目录结构和 blob 对象索引）以及一个 <strong>提交</strong> 对象（包含着指向前述树对象的指针和所有提交信息）。</p>
<p><img src="https://git-scm.com/book/en/v2/images/commit-and-tree.png" alt="首次提交对象及其树结构。" style="zoom:67%;" /></p>
<p>做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。</p>
<p><img src="https://git-scm.com/book/en/v2/images/commits-and-parents.png" alt="提交对象及其父对象。" style="zoom:67%;" /></p>
<p>Git 的分支，其实本质上仅仅是指向提交对象的可变指针。</p>
<p><strong>分支创建</strong></p>
<p>Git 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的指针。比如，创建一个 testing 分支， 你需要使用 <code>git branch</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch testing<br></code></pre></td></tr></table></figure>
<p><img src="https://git-scm.com/book/en/v2/images/two-branches.png" alt="两个指向相同提交历史的分支。" style="zoom:67%;" /></p>
<p>Git 是怎么知道当前在哪一个分支上呢？很简单，它有一个名为 <code>HEAD</code> 的特殊指针，指向当前所在的本地分支。</p>
<p><strong>分支切换</strong></p>
<p>要切换到一个已存在的分支，需要使用 <code>git checkout</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout testing<br></code></pre></td></tr></table></figure>
<p>这样 <code>HEAD</code> 就指向 <code>testing</code> 分支了。</p>
<p><strong>新建分支</strong></p>
<p>想要新建一个分支并同时切换到那个分支上，你可以运行一个带有 <code>-b</code> 参数的 <code>git checkout</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout -b iss53<br>Switched to a new branch <span class="hljs-string">&quot;iss53&quot;</span><br></code></pre></td></tr></table></figure>
<p>它是下面两条命令的简写：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch iss53<br>$ git checkout iss53<br></code></pre></td></tr></table></figure>
<p><img src="https://git-scm.com/book/en/v2/images/basic-branching-2.png" alt="创建一个新分支指针。" style="zoom: 50%;" /></p>
<p>你在新建的分支上上工作，并且做了一些提交。 在此过程中，<code>iss53</code> 分支在不断的向前推进。</p>
<p><img src="https://git-scm.com/book/en/v2/images/basic-branching-3.png" alt="`iss53` 分支随着工作的进展向前推进。" style="zoom:67%;" /></p>
<p>现在有个紧急问题等待你来解决。你不必把这个紧急问题和 <code>iss53</code> 的修改混在一起，也不需要花大力气来还原关于 53# 问题的修改，你所要做的仅仅是切换回 <code>master</code> 分支。在你这么做之前，要留意你的工作目录和暂存区里那些还没有被提交的修改， 它可能会和你即将检出的分支产生冲突从而阻止 Git 切换到该分支。 最好的方法是，在你切换分支之前，保持好一个干净的状态。</p>
<p>现在，我们假设你已经把你的修改全部提交了，这时你可以切换回 <code>master</code> 分支了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout master<br></code></pre></td></tr></table></figure>
<p>当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。</p>
<p>接下来，你要修复这个紧急问题。建立一个 <code>hotfix</code> 分支，在该分支上工作直到问题解决：</p>
<p><img src="https://git-scm.com/book/en/v2/images/basic-branching-4.png" alt="基于 `master` 分支的紧急问题分支（hotfix branch）。" style="zoom: 67%;" /></p>
<p>你可以运行你的测试，确保你的修改是正确的，然后将 <code>hotfix</code> 分支合并回你的 <code>master</code> 分支来部署到线上。可以使用 <code>git merge</code> 命令来达到上述目的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout master<br>$ git merge hotfix<br></code></pre></td></tr></table></figure>
<p>现在，最新的修改已经在 <code>master</code> 分支所指向的提交快照中，你可以着手发布该修复了。</p>
<p><img src="https://git-scm.com/book/en/v2/images/basic-branching-5.png" alt="`master` 被快进到 `hotfix`。" style="zoom:67%;" /></p>
<p>你应该先删除 <code>hotfix</code> 分支，因为你已经不再需要它了 —— <code>master</code> 分支已经指向了同一个位置。你可以使用带 <code>-d</code> 选项的 <code>git branch</code> 命令来删除分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch -d hotfix<br></code></pre></td></tr></table></figure>
<p>现在你可以切换回你正在工作的分支继续你的工作了。</p>
<p><strong>合并分支</strong></p>
<p>假设你已经修正了 #53 问题，并且打算将你的工作合并入 <code>master</code> 分支。你只需要检出到你想合并入的分支，然后运行 <code>git merge</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout master<br>Switched to branch <span class="hljs-string">&#x27;master&#x27;</span><br>$ git merge iss53<br>Merge made by the <span class="hljs-string">&#x27;recursive&#x27;</span> strategy.<br>index.html |    1 +<br>1 file changed, 1 insertion(+)<br></code></pre></td></tr></table></figure>
<p>这和之前合并 <code>hotfix</code> 分支的时候看起来有一点不一样。 在这种情况下，你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，现在的 <code>master</code> 分支所在提交并不是 <code>iss53</code> 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照（<code>C4</code> 和 <code>C5</code>）以及这两个分支的公共祖先（<code>C2</code>），做一个简单的三方合并。</p>
<p><img src="https://git-scm.com/book/en/v2/images/basic-merging-1.png" alt="一次典型合并中所用到的三个快照。" style="zoom:67%;" /></p>
<p>Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。</p>
<p><img src="https://git-scm.com/book/en/v2/images/basic-merging-2.png" alt="一个合并提交。" style="zoom:67%;" /></p>
<p>既然你的修改已经合并进来了，就不再需要 <code>iss53</code> 分支了。 现在你可以在任务追踪系统中关闭此项任务，并删除这个分支。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch -d iss53<br></code></pre></td></tr></table></figure>
<p><strong>遇到冲突时的分支合并</strong></p>
<p>有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们，在合并它们的时候就会产生合并冲突。</p>
<p>此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 <code>git status</code> 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件，你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span>contact : email.support@github.com<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>=======<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span><br> please contact us at support@github.com<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html<br></code></pre></td></tr></table></figure>
<p><code>HEAD</code> 所指示的版本在这个区段的上半部分（<code>=======</code> 的上半部分），而 <code>iss53</code> 分支所指示的版本在 <code>=======</code> 的下半部分。 为了解决冲突，你必须选择使用由 <code>=======</code> 分割的两部分中的一个，或者你也可以自行合并这些内容。</p>
<p>在你解决了所有文件里的冲突之后，对每个文件使用 <code>git add</code> 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。你可以再次运行 <code>git status</code> 来确认所有的合并冲突都已被解决。</p>
<p>如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入 <code>git commit</code> 来完成合并提交。</p>
<p><strong>分支管理</strong></p>
<p><code>git branch</code> 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表。</p>
<p>如果需要查看每一个分支的最后一次提交，可以运行 <code>git branch -v</code> 命令。</p>
<p><strong>远程分支</strong></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Git 使用指南</p><p><a href="https://brucehan98@github.io/2021/10/02/Git使用指南/">https://brucehan98@github.io/2021/10/02/Git使用指南/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Bruce Han</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-10-02</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-06-19</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><hr style="height:1px; margin:0.5rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="../../../../tags/git/">git </a></div></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="../../../../img/alipay.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="../../../../img/wechat.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="../../../11/29/E2E-ToD/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">E2E-ToD</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="../../../09/01/Neo4j%E4%BD%BF%E7%94%A8/"><span class="level-item">Neo4j Cypher 基本用法</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "d31deb30e3bc1ff02a5dfc22d603d9b8",
            repo: "brucehan98.github.io",
            owner: "BruceHan98",
            clientID: "84666a45ad34d2937a18",
            clientSecret: "f2432742d8824e7bd1006ae69b85f0488f928759",
            admin: ["BruceHan98"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#1-工作原理"><span class="level-left"><span class="level-item">1</span><span class="level-item">1. 工作原理</span></span></a></li><li><a class="level is-mobile" href="#2-配置"><span class="level-left"><span class="level-item">2</span><span class="level-item">2. 配置</span></span></a></li><li><a class="level is-mobile" href="#3-获取-Git-仓库"><span class="level-left"><span class="level-item">3</span><span class="level-item">3. 获取 Git 仓库</span></span></a></li><li><a class="level is-mobile" href="#4-记录更新"><span class="level-left"><span class="level-item">4</span><span class="level-item">4. 记录更新</span></span></a></li><li><a class="level is-mobile" href="#5-查看提交历史"><span class="level-left"><span class="level-item">5</span><span class="level-item">5. 查看提交历史</span></span></a></li><li><a class="level is-mobile" href="#6-撤销操作"><span class="level-left"><span class="level-item">6</span><span class="level-item">6. 撤销操作</span></span></a></li><li><a class="level is-mobile" href="#7-管理远程仓库"><span class="level-left"><span class="level-item">7</span><span class="level-item">7. 管理远程仓库</span></span></a></li><li><a class="level is-mobile" href="#8-打标签"><span class="level-left"><span class="level-item">8</span><span class="level-item">8. 打标签</span></span></a></li><li><a class="level is-mobile" href="#9-Git-分支"><span class="level-left"><span class="level-item">9</span><span class="level-item">9. Git 分支</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="../../../../js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer" style="padding-bottom: 4rem;"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="../../../../index.html"><img src="../../../../img/logo.svg" alt="Bruce Han&#039;s Blog" height="18"></a><p class="is-size-7"><span>&copy; 2023 Bruce Han</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><a href="https://beian.miit.gov.cn/" target="_blank">津ICP备2021007415号-1</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="../../../../js/column.js"></script><script src="../../../../js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="../../../../js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="../../../../js/main.js" defer></script><script src="../../../../js/night.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="../../../../js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"../../../../content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body><script type="text/javascript" src="/js/mathjax-config.js"></script></html>