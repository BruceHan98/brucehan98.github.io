<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>计算机网络基础 - Bruce Han&#039;s Blog</title><link rel="manifest" href="../../../../manifest.json"><meta name="application-name" content="Bruce Han&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Bruce Han&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="计算机网络——学习笔记"><meta property="og:type" content="blog"><meta property="og:title" content="计算机网络基础"><meta property="og:url" content="https://brucehan98@github.io/2022/10/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="Bruce Han&#039;s Blog"><meta property="og:description" content="计算机网络——学习笔记"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://pic3.zhimg.com/80/v2-f7db63b1f00cbd8170e1435616e06216_720w.webp"><meta property="og:image" content="https://pic3.zhimg.com/80/v2-c72fce5494ca8ee12244189430f12cea_720w.webp"><meta property="og:image" content="https://pic4.zhimg.com/80/v2-5f4034bc11c3a48a1d1a115f9ee0259b_720w.webp"><meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20220709/165763959_1657380213137/AE6224538ED4EE3558D39715E51CD4B2"><meta property="og:image" content="https://uploadfiles.nowcoder.com/images/20220709/165763959_1657380281024/2CDADE524B158B53F2E39A312BC1C66E"><meta property="og:image" content="https://pic002.cnblogs.com/images/2012/426620/2012072810301161.png"><meta property="og:image" content="https://img-blog.csdnimg.cn/5ce1ca640f0545c38d7a56a959a929f7.webp"><meta property="article:published_time" content="2022-10-20T10:45:48.000Z"><meta property="article:modified_time" content="2022-10-25T09:39:10.446Z"><meta property="article:author" content="Bruce Han"><meta property="article:tag" content="计算机网络"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://pic3.zhimg.com/80/v2-f7db63b1f00cbd8170e1435616e06216_720w.webp"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://brucehan98@github.io/2022/10/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},"headline":"计算机网络基础","image":["https://pic3.zhimg.com/80/v2-f7db63b1f00cbd8170e1435616e06216_720w.webp","https://pic3.zhimg.com/80/v2-c72fce5494ca8ee12244189430f12cea_720w.webp","https://pic4.zhimg.com/80/v2-5f4034bc11c3a48a1d1a115f9ee0259b_720w.webp","https://pic002.cnblogs.com/images/2012/426620/2012072810301161.png","https://img-blog.csdnimg.cn/5ce1ca640f0545c38d7a56a959a929f7.webp"],"datePublished":"2022-10-20T10:45:48.000Z","dateModified":"2022-10-25T09:39:10.446Z","author":{"@type":"Person","name":"Bruce Han"},"publisher":{"@type":"Organization","name":"Bruce Han's Blog","logo":{"@type":"ImageObject","url":"https://brucehan98@github.io/img/logo.svg"}},"description":"计算机网络——学习笔记"}</script><link rel="canonical" href="https://brucehan98@github.io/2022/10/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="icon" href="../../../../img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/6.0.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/xcode.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="../../../../css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdnjs.loli.net/ajax/libs/pace/1.2.4/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="../../../../index.html"><img src="../../../../img/logo.svg" alt="Bruce Han&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="../../../../index.html">首页</a><a class="navbar-item" href="../../../../archives">归档</a><a class="navbar-item" href="../../../../categories">分类</a><a class="navbar-item" href="../../../../tags">标签</a><a class="navbar-item" href="../../../../about">关于</a></div><div class="navbar-end"><a class="navbar-item night" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com/BruceHan98"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article" style="padding-left: 2rem; padding-right: 2rem; padding-top: 1rem; padding-bottom: 1rem"><h1 class="title is-size-4 is-size-4-mobile" style="font-weight: bold; margin: 0.5rem 0;">计算机网络基础</h1><div class="article-meta is-size-6 is-uppercase level is-mobile" style="margin-top: 0.5rem;"><div class="level-left"><span class="level-item"><time dateTime="2022-10-20T10:45:48.000Z" title="2022-10-20T10:45:48.000Z">2022-10-20</time>发表</span><span class="level-item"><time dateTime="2022-10-25T09:39:10.446Z" title="2022-10-25T09:39:10.446Z">2022-10-25</time>更新</span><span class="level-item"><a class="link-muted" href="../../../../categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span><span class="level-item">43 分钟读完</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><div class="content" style="margin-top: 0.5rem; margin-bottom: 0.5rem;"><h3 /><p><strong>1. OSI 七层协议</strong></p>
<ul>
<li>物理层</li>
</ul>
<p>​        主要解决两台物理机之间的通信，通过二进制比特流的传输来实现，二进制数据表现为电流电压上的强弱，到达目的地再转化为二进制机器码。网卡、集线器工作在这一层。</p>
<ul>
<li>数据链路层</li>
</ul>
<p>​        接收来自物理层的位流形式的数据，并封装成<strong>帧</strong>，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。这一层在物理层提供的比特流的基础上，通过<strong>差错控制</strong>、<strong>流量控制</strong>方法，使有差错的物理线路变为无差错的数据链路。提供<strong>物理地址寻址</strong>功能。交换机工作在这一层。</p>
<ul>
<li>网络层</li>
</ul>
<p>​        将网络地址翻译成对应的物理地址，并决定如何将数据从发送方<strong>路由</strong>到接收方，通过<strong>路由选择算法</strong>为分组通过通信子网选择最佳路径。路由器工作在这一层。</p>
<ul>
<li>传输层</li>
</ul>
<p>​        传输层提供了进程间的<strong>逻辑通信</strong>，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。</p>
<ul>
<li>会话层</li>
</ul>
<p>建立会话，身份验证，权限鉴定等。</p>
<ul>
<li>表示层</li>
</ul>
<p>​        对数据格式进行编译，对收到或发出的数据根据应用层的特征进行处理，如处理为文字、图片、音频、视频、文档等，还可以对压缩文件进行解压缩、对加密文件进行解密等。</p>
<ul>
<li>应用层</li>
</ul>
<p>​        提供应用层协议，如 HTTP 协议，FTP 协议等等，方便应用程序之间进行通信。</p>
<p><strong>2. TCP/IP 五层模型</strong></p>
<ul>
<li>应用层：为应用程序提供交互服务，如域名系统DNS、HTTP协议、SMTP协议等。</li>
<li>传输层：负责向两台主机进程之间的通信提供数据传输服务，如 TCP、UDP 等。</li>
<li>网络层：选择合适的路由和交换结点，确保数据及时传送。主要包括 IP 协议。</li>
<li>数据链路层：将网络层的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。</li>
<li>物理层：实现相邻节点间比特流的透明传输，尽可能屏蔽传输介质和物理设备的差异。</li>
</ul>
<p><strong>3. HTTP 是什么？常见的状态码？</strong></p>
<p>HTTP 是超文本传输协议，确立了一种计算机之间交流通信的规范以及相关的各种控制和错误处理方式。</p>
<p>常见的状态码：</p>
<ul>
<li>100：客户端应继续其请求</li>
<li>101：服务器根据客户端的请求切换协议</li>
<li><strong>200</strong>：OK，请求成功</li>
<li>201：成功请求并创建了新的资源</li>
<li>202：已经接受请求，但未处理完成</li>
<li><strong>203</strong>：非授权信息</li>
<li>204：服务器成功处理，但未返回内容</li>
<li><strong>301</strong>：请求的资源已被永久的移动到新的 URI</li>
<li>302：资源临时被移动</li>
<li>305：所请求的资源必须通过代理访问</li>
<li><strong>400</strong>：客户端请求的语法错误，服务器无法理解</li>
<li><strong>401</strong>：请求要求用户的身份认证</li>
<li><strong>403</strong>：服务器理解请求客户端的请求，但是拒绝执行此请求</li>
<li><strong>404</strong>：服务器无法根据客户端的请求找到资源（网页）</li>
<li>405：客户端请求中的方法被禁止</li>
<li>408：请求超时</li>
<li>410：客户端请求的资源已经不存在</li>
<li><strong>500</strong>：服务器内部错误，无法完成请求</li>
<li>501：服务器不支持请求的功能，无法完成请求</li>
<li>502：从远程服务器接收到了一个无效的响应</li>
<li>503：由于超载或系统维护，服务器暂时的无法处理客户端的请求</li>
</ul>
<p><strong>4. GET 和 POST 的区别</strong></p>
<ul>
<li>GET 请求，用于请求数据，无副作用的，是幂等的，且可缓存，请求的数据附加在 URL 之后，以 “?” 分割 URL 和传输数据，多个参数用 “&amp;” 连接。URL 的编码格式采用的是 ASCII 编码，所有的非 ASCII 字符都要编码之后再传输。</li>
<li>POST 请求，用于提交数据，有副作用，非幂等，不可缓存，POST 请求会把请求的数据放置在 HTTP 请求包的包体中。</li>
<li><p>GET 请求和 POST 请求数据的大小在 HTTP 协议中虽然没有做限制，但是实际上浏览器会有默认值。总体来说，少量的数据使用 GET，大量的数据使用POST。</p>
</li>
<li><p>GET 请求的数据会暴露在 URL 中，所以安全性比较低，比如密码是不能暴露的，就不能使用 GET 请求。而 POST 请求中，请求参数信息是放在请求头的，所以安全性较高，可以使用。在实际中，涉及到登录操作的时候，尽量使用HTTPS请求，安全性更好。</p>
</li>
</ul>
<p><strong>5. TCP 与 UDP 的区别</strong></p>
<ul>
<li><p>TCP 作为面向流的协议，提供可靠的、面向连接的传输服务，并且提供点对点通信。</p>
</li>
<li><p>UDP 作为面向报文的协议，不提供可靠交付，并且不需要连接，不仅仅对点对点，也支持多播和广播。</p>
</li>
</ul>
<p><strong>6. 为什么 TCP 传输是可靠的？</strong></p>
<ul>
<li>TCP 有<strong>三次握手</strong>建立连接，<strong>四次挥手</strong>关闭连接的机制。</li>
<li>除此之外还有<strong>滑动窗口</strong>和<strong>拥塞控制</strong>算法。</li>
<li>最关键的是还保留<strong>超时重传</strong>的机制。</li>
<li>同时，对于每份报文也存在<strong>校验</strong>，保证每份报文可靠性。</li>
</ul>
<p><strong>7. 为什么 UDP 传输不可靠？</strong></p>
<ul>
<li>UDP 是面向数据报无连接的，数据报发出去就不保留数据备份了。</li>
<li>报头部加入校验和复用。</li>
<li>UDP 没有服务器和客户端的概念。</li>
<li>UDP 报文过长的话是交给 IP 切成小段，如果某段报废报文就废了。</li>
</ul>
<p><strong>8. 简述 TCP 的滑动窗口？</strong></p>
<p>如果发送者发送数据过快，接收者来不及接收，那么就会有分组丢失。为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是<strong>流量控制</strong>。流量控制根本目的是<strong>防止分组丢失</strong>，它是构成TCP可靠性的一方面。</p>
<p>滑动窗口是传输层进行<strong>流量控制</strong>的一种措施，接收方通过告诉发送方自己的窗口大小，从而控制发送方的发送速度，防止发送方发送速度过快而导致接收方被淹没。</p>
<p>当发送者收到了一个窗口为 0 的应答，发送者便停止发送，等待接收者的下一个应答。但是如果这个窗口不为 0 的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生<strong>死锁</strong>。</p>
<p>为了避免流量控制引发的死锁，TCP 使用了<strong>持续计时器</strong>。每当发送者收到一个 0 窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回 0 窗口，则重置该计时器继续等待；若窗口不为 0，此时重置发送窗口后开始发送，这样就避免了死锁的产生。</p>
<p><strong>9. 简述 TCP 的拥塞控制？</strong></p>
<p>拥塞是指一个或者多个交换点的<strong>数据报超载</strong>，而 TCP 又有<strong>重传机制</strong>，导致<strong>过载</strong>。</p>
<p>拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：</p>
<p>（ 1 ）慢开始、拥塞避免（ 2 ）快重传、快恢复。</p>
<ul>
<li>慢开始：</li>
</ul>
<p>​        发送方维持一个叫做<strong>拥塞窗口</strong> cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。</p>
<p>​        慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。</p>
<p>​        一个传输轮次所经历的时间，也就是往返时间 RTT，而且每经过一个传输轮次（transmission round），拥塞窗口 cwnd 就加倍。</p>
<p>​        为了防止拥塞窗口 cwnd 增长过大引起网络拥塞，还需要设置一个慢开始门限 ssthresh 状态变量。</p>
<p>​        当 cwnd &lt; ssthresh 时，使用慢开始算法。</p>
<p>​        当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</p>
<p>​        当 cwnd = ssthresh 时，即可使用慢开始算法，也可使用拥塞避免算法。</p>
<ul>
<li>拥塞避免</li>
</ul>
<p>​        拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加1，而不是加倍。这样拥塞窗口按<strong>线性</strong>规律缓慢增长。</p>
<p>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有按时收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限 ssthresh 设置为出现拥塞时的发送窗口大小的一半（但不能小于2）。然后把拥塞窗口 cwnd 重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p>
<p><img src="https://pic3.zhimg.com/80/v2-f7db63b1f00cbd8170e1435616e06216_720w.webp" alt="img" style="zoom:67%;" /></p>
<ul>
<li>快重传</li>
</ul>
<p>快重传要求接收方在收到一个失序的报文段后就立即发出重复确认而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p>
<p><img src="https://pic3.zhimg.com/80/v2-c72fce5494ca8ee12244189430f12cea_720w.webp" alt="img" style="zoom:67%;" /></p>
<ul>
<li>快恢复</li>
</ul>
<p>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把 ssthresh 门限减半（为了预防网络发生拥塞），但是接下去并不执行慢开始算法。考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将 cwnd 设置为 ssthresh 减半后的值，然后执行拥塞避免算法，使 cwnd 缓慢增大。</p>
<p><img src="https://pic4.zhimg.com/80/v2-5f4034bc11c3a48a1d1a115f9ee0259b_720w.webp" alt="img" style="zoom:67%;" /></p>
<p><strong>10. TCP 三次握手</strong></p>
<p>假设发送端为客户端，接收端为服务端。开始时客户端和服务端的状态都是 CLOSED。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20220709/165763959_1657380213137/AE6224538ED4EE3558D39715E51CD4B2" alt="img" style="zoom: 33%;" /></p>
<ul>
<li>第一次握手：客户端向服务端发起建立连接请求，客户端会随机生成一个起始序列号 x，客户端向服务端发送的字段中包含标志位 SYN=1，序列号 seq=x。客户端发送请求后，状态由 CLOSED 变为 SYN-SENT。</li>
<li>第二次握手：服务端在收到客户端发来的报文后，由标志位 SYN=1 知道客户端请求建立连接，服务端将标志位 SYN和 ACK 都置为1，ack=x+1，并随机产生一个值 seq=y，并将该数据包发送给客户端确认连接请求。服务端的状态由 LISTEN 变为 SYN-RCVD。</li>
<li>第三次握手：客户端收到确认后检查，如果正确则将标志位 ACK为1，ack=y+1，并将该数据包发送给服务端，客户端进入 ESTABLISHED 状态。服务端对收到的数据包检查如果正确则连接建立成功，进入 ESTABLISHED 状态。客户端和服务端进入 ESTABLISHED 状态，完成三次握手。随后客户端和服务端之间可以开始传输数据了。</li>
</ul>
<p><strong>11. 两次握手可以吗？</strong></p>
<p>不可以。“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。</p>
<p>例如以下情形：假设不采用“三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。</p>
<p><strong>12. TCP 四次挥手</strong></p>
<p><img src="https://uploadfiles.nowcoder.com/images/20220709/165763959_1657380281024/2CDADE524B158B53F2E39A312BC1C66E" alt="img" style="zoom:33%;" /></p>
<ul>
<li><p>第一次挥手：客户端发送关闭连接报文（FIN=1，seq=u），并停止再发送数据，主动关闭 TCP 连接，进入FIN-WAIT-1（终止等待1）状态，等待服务端的确认。</p>
</li>
<li><p>第二次挥手：服务端收到关闭连接报文后，发出确认报文（ACK=1，ack=u+1，seq=v），进入 CLOSE_WAIT（关闭等待）状态。此时 TCP 处于半关闭状态，客户端已经没有要发送到数据了，但服务端仍可以向客户端发送数据。</p>
</li>
<li>第三次挥手：服务端发送关闭连接报文，用来关闭服务端到客户端的数据传送，服务端进入 LAST_ACK 状态，等待客户端确认。</li>
<li>第四次挥手：客户端收到关闭报文后，进入TIME_WAIT 状态，此时 TCP 未释放掉，需要经过时间等待计时器设置的时间 2 * MSL（最大报文段生存时间）后，才进入 CLOSED 状态。客户端发送一个确认报文给服务端，服务端确认后，进入 CLOSED 状态，完成四次挥手。</li>
</ul>
<p><strong>12. 为什么要四次挥手？</strong></p>
<p>主要原因是当服务端收到客户端的关闭连接请求报文后，服务端可能还有数据没发送完，不会立即 close。</p>
<p><strong>24. 第四次挥手为什么要等待 2MSL？</strong></p>
<ul>
<li>1 个 MSL 保证四次挥手中主动关闭方最后的 ACK 报文能够最终到达对端</li>
<li>1 个 MSL 保证对端如果没有收到 ACK 那么进行重传的 FIN 报文能够到达</li>
</ul>
<p><strong>13. TCP 连接的特点</strong></p>
<ul>
<li>TCP 是面向连接的传输层协议</li>
<li>TCP 连接是一对一的</li>
<li>TCP 提供可靠交付的服务（每份报文存在校验）</li>
<li>TCP 提供全双工通信</li>
<li>TCP 是面向字节流的</li>
</ul>
<p><strong>14. 简述 DNS 协议及解析过程</strong></p>
<p>DNS 是 Domain Name System 的缩写，中文是“域名系统”。DNS 协议是基于 UDP 的应用层协议，它的功能是根据用户提供的域名，解析出该域名对应的 IP 地址，从而给客户端进行访问。</p>
<p>域名的构成：</p>
<p>www.baidu.com</p>
<p>其中，”www” 是三级域名，”baidu” 是二级域名，”com” 是顶级域名</p>
<p>域名服务器划分：</p>
<ul>
<li>本地域名服务器：当一个主机发出 DNS 查询请求时，这个查询请求报文就发送给本地域名服务器。每一个互联网服务提供者 ISP 都可以拥有一个本地域名服务器。</li>
<li>根域名服务器：根域名服务器是最高层次的域名服务器，知道所有<strong>顶级域名</strong>服务器的域名和 IP 地址。如果本地域名服务器无法对域名进行解析，就<strong>首先</strong>求助于根域名服务器。</li>
<li>顶级域名服务器：顶级域名服务器负责管理在该服务器注册的所有<strong>二级域名</strong>。当收到 DNS 查询请求时，就给出相应的回答（可能是最后的结果，也可能是下一步需要查询的域名服务器的 IP 地址）。</li>
<li>权威域名服务器：权限域名服务器是负责一个区的域名服务器，如 “baidu.com” 下的所有域名。当一个权限域名服务器还不能给出最后的查询回答时，就会告知发出查询请求的DNS客户，下一步应当找哪一个权威域名服务器。</li>
</ul>
<p>域名解析一般采用<strong>递归查询</strong>的方式进行。解析过程：</p>
<ol>
<li>客户机发出查询请求，首先在本地缓存（浏览器缓存、系统 hosts 缓存、路由器缓存等）中查找，若没有找到，就会将请求发送给 DNS 服务器。</li>
<li>如果在本机上无法完成域名的解析，那么系统只能请求本地域名解析服务系统进行，本地域名服务器一般都缓存了大部分的域名解析的结果，本地域名服务器可能是当地的运行商，如联通、电信或校园网等。</li>
<li>如果在本地域名服务器还不能完成解析，那么本地域名服务器首先向根域名服务器发起查询。根域名服务器收到请求后会查看区域文件记录，若查询到记录，则返回解析的 IP 地址；若无则将其管辖范围内顶级域名（如.com、.cn等）服务器 IP 告诉本地 DNS 服务器。</li>
<li>若根域名服务器未完成解析，则本地域名服务器向收到的顶级域名服务器发起查询。顶级域名服务器收到请求后会查看区域文件记录，若查询到记录，则返回解析的 IP 地址；若无则将其管辖范围内权威服务器 IP 告诉本地 DNS 服务器。</li>
<li>若顶级域名服务器未完成解析，则本地域名服务器向收到的权威域名服务器发起查询。权威域名服务器收到请求后会查看区域文件记录，若查询到记录，则返回解析的 IP 地址；若无则将下一个应当查询的权威服务器 IP 告诉本地 DNS 服务器。</li>
<li>本地域名服务器将最终的查询结果返回到客户机，完成域名解析。</li>
</ol>
<p><strong>15. HTTP 协议及特点</strong></p>
<p>HTTP 协议是超文本传输协议。它是基于 TCP 协议的应用层传输协议，即客户端和服务端进行<a target="_blank" rel="noopener" href="https://www.nowcoder.com/jump/super-jump/word?word=数据">数据</a>传输的一种规则。该协议本身HTTP 是一种无状态的协议。</p>
<ul>
<li><p>HTTP 允许传输<strong>任意类型</strong>的数据。传输的类型由Content-Type加以标记。</p>
</li>
<li><p>HTTP 请求是无状态的，对于客户端每次发送的请求，服务器都认为是一个新的请求，上一次会话和下一次会话之间没有联系。</p>
</li>
<li>支持客户端/服务端模式</li>
</ul>
<p><strong>16. HTTP 请求报文格式</strong></p>
<p>HTTP 请求由<strong>请求行、请求头、空行和请求数据</strong>四个部分组成。</p>
<p><img src="https://pic002.cnblogs.com/images/2012/426620/2012072810301161.png" alt="img"></p>
<ul>
<li><p>请求行：请求行由<strong>请求方法</strong>字段、<strong>URL</strong>字段和 <strong>HTTP协议版本</strong> 字段3个字段组成，用空格分隔。</p>
<p>例如，GET /index.html HTTP/1.1。</p>
<ul>
<li><p>请求方法：GET、POST、HEAD、PUT、DELETE、OPTIONS 等</p>
<ul>
<li><p>GET：最常见的一种请求方式，要求服务器将 URL 定位的资源放在响应报文的数据部分，回送给客户端。使用 GET 方法时，请求参数和对应的值直接附加在 URL 后面，使用一个问号 “?” 将 URL 与请求参数分开。显然，这种方式不适合传送私密数据。另外，浏览器通常对传递参数长度进行限制，因此 GET 方法也不适合传送大量数据。</p>
</li>
<li><p>POST：POST 方法将请求参数封装在 HTTP 请求数据中，以名称/值的形式出现，对传送的数据大小没有限制，可以传输大量数据，而且也不会显示在 URL 中。</p>
</li>
<li>HEAD：HEAD 就像 GET，只不过服务端接收到 HEAD 请求后只返回响应头，而不会发送响应内容。当我们只需要查看某个页面的状态的时候，使用 HEAD 是非常高效的，因为在传输的过程中省去了页面内容。</li>
<li>PUT：用客户端向服务端传送到数据替换指定文档的内容</li>
</ul>
</li>
</ul>
</li>
<li><p>请求头：请求头部由<strong>关键字/值</strong>对组成，每行一对，关键字和值用英文冒号“:”分隔。典型的请求头有：</p>
<ul>
<li>User-Agent：产生请求的浏览器类型</li>
<li>Accept：客户端可识别的内容类型列表</li>
<li>Host：请求的主机名</li>
</ul>
</li>
<li><p>空行：最后一个请求头之后是一个空行，用于分割请求头与请求体</p>
</li>
<li><p>请求数据：请求数据不在 GET 方法中使用，而是在 POST 方法中使用。POST 方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是 Content-Type 和 Content-Length。</p>
</li>
</ul>
<p><strong>17. HTTP 响应报文格式</strong></p>
<p>HTTP 响应也由四个部分组成，分别是<strong>状态行</strong>、<strong>消息报头</strong>、<strong>空行</strong>和<strong>响应正文</strong>。</p>
<ul>
<li>状态行：由 HTTP 协议版本、状态码和状态描述三部分组成。</li>
<li>响应头：响应头字段主要有 connection、content-type、content-encoding、content-length、set-cookie、Last-Modified，、Cache-Control、Expires 等。</li>
<li>空行：用于分割响应头与响应体。</li>
<li>响应体：服务器返回给客户端的内容。</li>
</ul>
<p><strong>18. HTTP 长连接与短链接</strong></p>
<ul>
<li>短链接：HTTP 1.0 默认使用的是短连接。浏览器和服务器每进行一次 HTTP 传输，就建立一次连接，任务结束就中断连接。</li>
<li>长连接：HTTP/1.1 起，默认使用长连接。长连接，指的是<strong>复用TCP连接</strong>。多个HTTP请求可以复用同一个TCP连接，这就节省了TCP连接建立和断开的消耗。</li>
</ul>
<p><strong>19. HTTP 1.0 和 HTTP 1.1 和 HTTP 2.0 的区别</strong></p>
<ul>
<li>HTTP 1.0：规定了请求头和请求体，响应头和响应体，每一个请求都是一个单独的连接，做不到连接的复用。</li>
<li>HTTP 1.1：<ul>
<li>HTTP1.1 默认开启长连接，在一个 TCP 连接上可以传送多个 HTTP 请求和响应。改善了短链接的性能开销。</li>
<li>支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li>
</ul>
</li>
<li>HTTP 2.0：<ul>
<li>新的二进制格式：HTTP 1.1 基于文本格式传输数据，HTTP 2.0 采用二进制格式传输数据，解析更高效。</li>
<li>提出<strong>多路复用</strong>。在一个连接里，允许同时发送多个请求或响应，并且能够并行传输而不被阻塞。</li>
<li>头部压缩：HTTP 1.1 的头部有大量信息，每次都要重复发送；HTTP 2.0 将 header 从数据中分离，并封装成头帧和数据帧，使用特定算法压缩头帧，有效减少头部信息大小；并且 HTTP 2.0 在客户端和服务端记录了之前发送的键值对，对于相同的数据，不需要重复发送。</li>
<li>服务端推送：HTTP 2.0 允许服务器向客户端推送资源，无需客户端发送请求到服务端获取。</li>
</ul>
</li>
</ul>
<p><strong>20. HTTP vs HTTPS</strong></p>
<ul>
<li>HTTP 是超文本传输协议，明文传输信息；HTTPS 是具有安全性的 SSL 加密传输协议</li>
<li>HTTP 使用端口号 80；HTTPS 使用端口号 443</li>
<li>HTTPS 协议需要 CA 机构签发的证书</li>
<li>HTTP 运行在 TCP 协议之上；HTTPS 运行在 SSL 协议之上，SSL 运行在 TCP 协议之上</li>
</ul>
<p><strong>21. HTTPs 连接过程</strong></p>
<p>HTTPS 建立连接的过程中，一共发起<strong>两次请求</strong>，进行<strong>非对称和对称两次加密</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/5ce1ca640f0545c38d7a56a959a929f7.webp" alt="img" style="zoom: 67%;" /></p>
<ol>
<li>客户端发送一个 https 请求到服务端</li>
<li>服务端准备配置好的数字证书，包含公钥和私钥</li>
<li>服务端将证书传送给客户端，证书中包含了很多信息，比如证书的颁发机构，过期时间，网址，<strong>公钥</strong>等</li>
<li>客户端解析证书，由客户端的 TLS 完成，首先会验证证书是否有效，比如颁发机构，过期时间等。如果有异常，就会弹出警告信息，并结束通信。如果正常，则生成一个随机值（用于对称加密），然后用服务端的公钥对随机值进行<strong>非对称加密</strong></li>
<li>客户端将加密后的随机值传送到服务端</li>
<li>服务端使用证书的私钥非对称解密得到客户端的随机值，用获取的随机值将传输的明文内容进行<strong>对称加密</strong></li>
<li>服务端把对称加密后的数据传输到客户端</li>
<li>客户端通过随机值对称解密获取明文内容</li>
</ol>
<p><strong>22. 对称加密 vs 非对称加密</strong></p>
<ul>
<li>对称加密：通信双方使用<strong>相同的密钥</strong>进行加密。特点是加密速度快，但是缺点是密钥泄露会导致密文数据被破解。常见的对称加密有 AES 和 DES 算法。</li>
<li>非对称加密：需要生成两个密钥，<strong>公钥和私钥</strong>。公钥是公开的，任何人都可以获得，而私钥是私人保管的。公钥负责加密，私钥负责解密；或者私钥负责加密，公钥负责解密。这种加密算法<strong>安全性更高</strong>，但是<strong>计算量相比对称加密大很多</strong>，加密和解密都很慢。常见的非对称算法有 RSA 和 DSA。</li>
</ul>
<p><strong>22. 浏览器从输入 URL 到返回页面的过程</strong></p>
<ol>
<li><p>浏览器对 URL 检查</p>
<ul>
<li>检查 URL 是否合法</li>
<li>判断 URL 是否完整，如果不完整，浏览器可能会对其补全</li>
</ul>
</li>
<li><p>DNS 解析（以下某一步完成解析则返回解析后的 IP 地址）</p>
<ul>
<li>检查浏览器缓存和本地 hosts 文件</li>
<li>查找本地 DNS 服务器缓存</li>
<li>递归查询 DNS</li>
</ul>
</li>
<li><p>建立 TCP 连接</p>
<p>当浏览器获取到服务器的 IP 地址后，会用一个随机的端口（1024 &lt; 端口号 &lt; 65535）向服务器的 80 端口发起 TCP 连接请求（HTTP 默认约定 80 端口，HTTPS 为 443 端口），通过 TCP 三次握手，建立 TCP 连接。</p>
</li>
<li><p>服务器响应</p>
<p>服务器根据浏览器发送的 HTTP 请求发送响应报文</p>
</li>
<li><p>浏览器渲染</p>
<p>浏览器将收到的响应报文进行渲染，得到显示的网页</p>
<ul>
<li>处理 HTML 并构建 DOM 树</li>
<li>处理 CSS 并构建 CSSOM 树</li>
<li>将 DOM 与 CSSOM 合并成一个渲染树</li>
<li>根据渲染树布局，计算每个结点的几何信息</li>
<li>将各个结点绘制到屏幕上</li>
</ul>
</li>
<li><p>断开连接</p>
<p>现在的浏览器页面为了优化请求的耗时，默认都会开启持久连接（keep-alive），当 tab 标签页被关闭的时候，会发起四次挥手断开 TCP 的连接。</p>
</li>
</ol>
<p><strong>23. Cookie vs Session</strong></p>
<p>由于 HTTP 协议是<strong>无状态</strong>的协议，需要用某种机制来<strong>标识用户身份</strong>，以跟踪用户的整个会话。常用的<strong>会话跟踪技术</strong>是 cookie 与 session。</p>
<ul>
<li><p><strong>cookie</strong> 是由<strong>服务器发给客户端</strong>的特殊信息，而这些信息以文本的方式<strong>存放在客户端</strong>，然后客户端每次向服务器发送请求的时候都会带上这些特殊的信息。</p>
<p>一个 cookie 的工作流程：当用户使用浏览器访问一个支持 cookie 的网站时，用户会提供包括用户名在内的个人信息并且提交至服务器；服务器会根据这些身份信息生成对应的 cookie，并通过响应报文回传给客户端（cookie 存放在 HTTP 响应头中）；当客户端浏览器接收到来自服务器的响应之后，浏览器会将 cookie 信息存放在一个统一的位置。然后，客户端再向服务器发送请求的时候，都会把相应的 cookie 存放在 <strong>HTTP 请求头</strong>发回至服务器；服务器就能够接收到来自客户端浏览器的带有 cookie 信息的请求，从而得到客户端特有的身份信息，然后动态生成与该客户端相对应的内容。</p>
</li>
<li><p><strong>session</strong> 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。</p>
</li>
<li><p>Cookie 与 Session 的区别？</p>
<ul>
<li>作用范围不同，Cookie 保存在客户端（浏览器），Session 保存在服务器端。</li>
<li>存取方式的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。</li>
<li>有效期不同，Cookie 可设置为保持较长时间，Session 一般保持时间较短，客户端关闭或者 Session 超时都会失效。</li>
<li>隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，Session 存储在服务端，安全性要好一些。</li>
<li>存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。</li>
</ul>
</li>
<li><p>如果浏览器禁用了 Cookie，如何保障整个机制的正常运转？</p>
<ul>
<li>第一种方案：每次请求中都携带一个 SessionID 的参数，记录对话状态</li>
<li>第二种方案：使用 Token 机制，服务端产生一个令牌，用来标识客户端。</li>
</ul>
</li>
<li><p>分布式 Session 的问题？</p>
<p>互联网公司为了可以支撑更大的流量，后端往往需要多台服务器共同来支撑前端用户请求，那如果用户在 A 服务器登录了，第二次请求跑到服务 B 就会出现登录失效问题。分布式 Session 一般会有以下几种解决方案：</p>
<ul>
<li>Nginx ip_hash 策略，服务端使用 Nginx 代理，每个请求按访问 IP 的 hash 分配，这样来自同一 IP 固定访问一个后台服务器，避免了在服务器 A 创建 Session，第二次分发到服务器 B 的现象。</li>
<li>Session 复制，任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。</li>
<li>共享 Session，服务端无状态化，将用户的 Session 等信息使用缓存中间件来统一管理，保障分发到每一个服务器的响应结果都一致。</li>
</ul>
</li>
</ul>
<p><strong>26. 什么是 DNS 劫持？</strong></p>
<p>DNS 劫持是在用户通过域名系统访问目标的时候<strong>劫持域名解析的回包</strong>，目标域名会被恶意地指向其他恶意 IP 地址，造成用户无法正常使用服务，甚至造成弹广告、挂马等危害。</p>
<p>DNS劫持最直接的手段是通过入侵 DNS 服务器，获取攻击目标域名的解析记录控制权，之后修改攻击目标域名的解析结果，等到 TTL 时间生效之后，所有对该域名的访问由原 IP 地址指向修改后的恶意 IP。</p>
<p><strong>27. 什么是 SYN 攻击？</strong></p>
<p>SYN 攻击利用 TCP 协议缺陷，通过发送大量的<strong>半连接请求</strong>，占用半连接队列，耗费服务端的 CPU 和内存资源。 </p>
<p>优化方式： </p>
<ol>
<li>缩短 SYN Timeout 时间 </li>
<li>记录 IP，若连续受到某个 IP 的重复 SYN 报文，从这个 IP 地址来的包会被一概丢弃。</li>
</ol>
</div><div class="article-licensing box"><div class="licensing-title"><p>计算机网络基础</p><p><a href="https://brucehan98@github.io/2022/10/20/计算机网络-学习笔记/">https://brucehan98@github.io/2022/10/20/计算机网络-学习笔记/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Bruce Han</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2022-10-20</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2022-10-25</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><hr style="height:1px; margin:0.5rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="../../../../tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络 </a></div></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="../../../../img/alipay.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="../../../../img/wechat.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="../%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">概率与统计</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="../../../03/10/PaddleOCR-Docker%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/"><span class="level-item">PaddleOCR Docker 服务部署</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/gitalk/1.7.2/gitalk.css"><script src="https://cdnjs.loli.net/ajax/libs/gitalk/1.7.2/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "9765b4ef3aa39648cf217fdd41c572e9",
            repo: "brucehan98.github.io",
            owner: "BruceHan98",
            clientID: "84666a45ad34d2937a18",
            clientSecret: "f2432742d8824e7bd1006ae69b85f0488f928759",
            admin: ["BruceHan98"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><!--!--></div><!--!--></div></div></section><footer class="footer" style="padding-bottom: 4rem;"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="../../../../index.html"><img src="../../../../img/logo.svg" alt="Bruce Han&#039;s Blog" height="18"></a><p class="is-size-7"><span>&copy; 2023 Bruce Han</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="../../../../js/column.js"></script><script src="../../../../js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="../../../../js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdnjs.loli.net/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="../../../../js/main.js" defer></script><script src="../../../../js/night.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="../../../../js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"../../../../content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body><script type="text/javascript" src="/js/mathjax-config.js"></script></html>